Index: polls/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nfrom django.contrib import messages\r\n\r\nfrom math import radians, sin, cos, sqrt, atan2\r\n\r\n# Create your views here.\r\nfrom django.shortcuts import render, redirect, get_object_or_404\r\nfrom django.utils.decorators import method_decorator\r\nfrom django.views import View\r\nfrom django.core.exceptions import ValidationError\r\nfrom django.utils import timezone\r\n\r\n#Login\r\nfrom django.contrib.auth.mixins import LoginRequiredMixin\r\nfrom django.views.decorators.cache import never_cache\r\n\r\nfrom Methods.Application import ApplicationMethods\r\nfrom Methods.Delete import DeleteAcct\r\nfrom Methods.Login import Login\r\nfrom Methods.Verification import VerifyAccount\r\nfrom Methods.forms import CreateAccountForm\r\n\r\nfrom polls.models import User, Event, SearchedArea, Application, ApplicationStatus\r\nfrom Methods.sendgrid_reset import CustomTokenGenerator, send_reset_email\r\nfrom polls.models import User\r\nfrom EventRadarProject.settings import EVENT_API_KEY\r\nimport re\r\n\r\n#For resetting password\r\nfrom django.contrib.auth import views as auth_views, authenticate, login\r\nfrom django.shortcuts import render\r\nfrom Methods.reset import Reset\r\nfrom django.utils.http import urlsafe_base64_decode\r\nfrom Methods.CustomTokenGenerator import CustomTokenGenerator\r\n\r\n\r\n\r\nfrom Methods.change_account_details import change_account_details\r\nfrom django.shortcuts import get_object_or_404\r\n\r\n\r\nfrom Methods.sendgrid_email import send_confirmation_email\r\n\r\n\r\nimport folium\r\nfrom folium.plugins import MarkerCluster\r\n\r\nfrom polls.geocoding import GeocodingService\r\nfrom django.contrib.auth.hashers import make_password\r\n\r\n#Mixins\r\nfrom Methods.SessionLoginMixin import SessionLoginRequiredMixin\r\nfrom Methods.userPermissions import UserRequiredMixin,AdminManagerRequiredMixin,EventManagerRequiredMixin,AdminRequiredMixin\r\n\r\nfrom polls.api import fetch_events_from_api\r\nimport json\r\n\r\n# Create your views here.\r\nimport logging\r\nfrom django.http import JsonResponse\r\nfrom django.views.decorators.http import require_POST\r\nfrom django.views.decorators.csrf import csrf_exempt\r\nfrom polls.config.category_mapping import category_mapping\r\nimport math\r\nfrom django.db.models import Max\r\nimport time\r\nfrom django.conf import settings\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass LoginAuth(View):\r\n    @method_decorator(never_cache)\r\n    def get(self, request):\r\n        if 'email' in request.session:\r\n            return redirect(\"homepage\")  #If logged in then go to homepage\r\n\r\n        response = render(request, \"login.html\")\r\n        response['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'\r\n        response['Pragma'] = 'no-cache'\r\n        response['Expires'] = '0'\r\n        return response\r\n\r\n    def post(self, request):\r\n        email = request.POST.get('email')\r\n        password = request.POST.get('password')\r\n\r\n        # Initialize errors dictionary\r\n        errors = {}\r\n\r\n        login_auth = Login()\r\n        # Check if fields are blank\r\n        if not login_auth.isNotBlank(email, password):\r\n            return render(request, \"login.html\", {\"error\": \"Invalid email or password\"})\r\n\r\n        elif login_auth.authenticate(email, password):\r\n                user = User.objects.get(email=email)\r\n                request.session['email'] = user.email\r\n                request.session[\"is_authenticated\"] = True\r\n                request.session['role'] = user.role\r\n                return redirect(\"homepage\")\r\n        else:\r\n\r\n            return render(request, \"login.html\", {\"error\": \"Invalid email or password\"})  # Show error message\r\nclass CreateAcct(View):\r\n    def get(self, request):\r\n        form = CreateAccountForm()\r\n        return render(request, \"create_account.html\", {\"form\": form})\r\n\r\n    def post(self, request):\r\n        form = CreateAccountForm(request.POST)\r\n        if form.is_valid():\r\n            user = form.save(commit=False)\r\n            user.password = make_password(user.password)  #hashes the password\r\n            user.role = 'User'\r\n            user.save()\r\n            send_confirmation_email(user)\r\n            return redirect(\"login\")\r\n        else:\r\n            print(f\"Form errors: {form.errors}\")\r\n            return render(request, \"create_account.html\", {\"form\": form})\r\nclass HomePage(SessionLoginRequiredMixin,View):\r\n    @method_decorator(never_cache)\r\n    def get(self, request, *args, **kwargs):\r\n        radius = request.session.get('radius', 5)\r\n        location_name = request.session.get('location', 'Milwaukee')\r\n        location_coords = request.session.get('location_coords')\r\n        if not location_coords:\r\n            geocoder = GeocodingService()\r\n            location_coords = geocoder.get_coordinates(location_name)\r\n            if not location_coords:\r\n                location_coords = (43.0389, -87.9065)\r\n            request.session['location_coords'] = location_coords\r\n        if isinstance(location_coords, tuple):\r\n            location = list(location_coords)\r\n        else:\r\n            location = location_coords\r\n\r\n        logger.info(f\"Session location: {request.session.get('location')}, radius: {request.session.get('radius')}, location_coords: {request.session.get('location_coords')}\")\r\n\r\n        max_searched_radius_data = SearchedArea.objects.filter(\r\n            latitude=location[0],\r\n            longitude=location[1]\r\n        ).aggregate(Max('radius'))\r\n\r\n        max_searched_radius = max_searched_radius_data['radius__max']\r\n\r\n        if max_searched_radius is not None and radius <= max_searched_radius:\r\n            needs_fetch = False\r\n            logger.info(f\"Found previous search for location ({location[0]}, {location[1]}) with max radius {max_searched_radius}. Requested radius {radius} is covered. No fetch needed.\")\r\n        else:\r\n            needs_fetch = True\r\n            if max_searched_radius is not None:\r\n                logger.info(f\"Largest previous search for location ({location[0]}, {location[1]}) was {max_searched_radius} miles. Requested radius {radius} is larger. Fetch required.\")\r\n            else:\r\n                logger.info(f\"No previous SearchedArea record found for location ({location[0]}, {location[1]}). Fetch required.\")\r\n\r\n        logger.info(f\"Final decision for needs_fetch: {needs_fetch}\")\r\n\r\n        events = self.get_events_within_radius(location[0], location[1], radius)\r\n        logger.info(f\"Displaying {len(events)} events currently in DB within {radius} miles.\")\r\n        \r\n        categorized_events = {}\r\n        for event in events:\r\n            category = event.category or \"Uncategorized\"\r\n            if category not in categorized_events:\r\n                categorized_events[category] = []\r\n            categorized_events[category].append(event)\r\n        \r\n        sorted_categories = sorted(categorized_events.keys())\r\n        \r\n        event_categories = []\r\n        for category in sorted_categories:\r\n            sorted_events = sorted(\r\n                categorized_events[category],\r\n                key=lambda e: self.calculate_distance(location[0], location[1], e.latitude, e.longitude)\r\n            )\r\n            event_categories.append({\r\n                'name': category,\r\n                'events': sorted_events \r\n            })\r\n        \r\n        for category_group in event_categories:\r\n            for event in category_group['events']:\r\n                event.is_expanded = False\r\n\r\n        map_html = self.generate_map(location[0], location[1], radius, events)\r\n\r\n        # Returning user's role (For permissions)\r\n        email = request.session.get(\"email\")\r\n        try:\r\n            user = User.objects.get(email=email)\r\n        except User.DoesNotExist:\r\n            logger.error(f\"User with email {email} does not exist. Redirecting to login.\")\r\n            request.session.flush()\r\n            return redirect(\"login\")\r\n\r\n        user_role = user.role\r\n        \r\n        for category_group in event_categories:\r\n            for event in category_group['events']:\r\n                event.distance = round(self.calculate_distance(\r\n                    location[0], location[1], event.latitude, event.longitude\r\n                ), 1)\r\n                \r\n                if event.description:\r\n                    lines = event.description.split('\\n')\r\n                    event.short_description = lines[0] if lines else \"\"\r\n                    \r\n                    phone_match = re.search(r'\\b(?:\\+\\d{1,2}\\s)?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\\b', event.description)\r\n                    event.phone = phone_match.group(0) if phone_match else None\r\n                    \r\n                    website_match = re.search(r'https?://[^\\s]+', event.description)\r\n                    event.website = website_match.group(0) if website_match else None\r\n        \r\n        context = {\r\n            'map_html': map_html,\r\n            'event_categories': event_categories,\r\n            'current_location': request.session.get('location_name', 'Milwaukee'),\r\n            'current_radius': radius,\r\n            'current_latitude': location[0],\r\n            'current_longitude': location[1],\r\n            'needs_fetch': needs_fetch,\r\n            'user_role': user_role\r\n        }\r\n\r\n        return render(request, \"homepage.html\", context)\r\n\r\n    def post(self, request):\r\n        location_name = request.POST.get('location', 'Milwaukee')\r\n        radius = request.POST.get('radius', 5)\r\n\r\n        try:\r\n            radius = int(radius)\r\n            if not (1 <= radius <= 50):\r\n                radius = 5\r\n        except (ValueError, TypeError):\r\n            radius = 5\r\n\r\n        geocoder = GeocodingService()\r\n        location_coords = geocoder.get_coordinates(location_name)\r\n\r\n        if not location_coords:\r\n            messages.error(request, f\"Could not find coordinates for '{location_name}'. Using previous location.\")\r\n            request.session['radius'] = radius\r\n        else:\r\n            request.session['location_name'] = location_name\r\n            request.session['radius'] = radius\r\n            request.session['location_coords'] = location_coords\r\n            logger.info(f\"POST request: Updated session location_name='{location_name}', radius={radius}, coords={location_coords}\")\r\n        return redirect('homepage')\r\n\r\n    def get_events_within_radius(self, center_lat, center_lon, radius_miles):\r\n        lat_change_per_mile = 1.0 / 69.0\r\n        lon_change_per_mile = 1.0 / (69.0 * math.cos(math.radians(center_lat)))\r\n\r\n        min_lat = center_lat - (radius_miles * lat_change_per_mile)\r\n        max_lat = center_lat + (radius_miles * lat_change_per_mile)\r\n        min_lon = center_lon - (radius_miles * lon_change_per_mile)\r\n        max_lon = center_lon + (radius_miles * lon_change_per_mile)\r\n\r\n        potential_events = Event.objects.filter(\r\n            latitude__gte=min_lat,\r\n            latitude__lte=max_lat,\r\n            longitude__gte=min_lon,\r\n            longitude__lte=max_lon\r\n        )\r\n        logger.info(f\"Found {potential_events.count()} potential events in bounding box for Haversine check.\")\r\n\r\n        nearby_events = []\r\n        for event in potential_events:\r\n            distance = self.calculate_distance(center_lat, center_lon, event.latitude, event.longitude)\r\n            if distance <= radius_miles:\r\n                nearby_events.append(event)\r\n\r\n        logger.info(f\"Filtered down to {len(nearby_events)} events within precise radius.\")\r\n        return nearby_events\r\n    \r\n    def calculate_distance(self, lat1, lon1, lat2, lon2):\r\n        \"\"\"\r\n        Calculate distance between two points using the Haversine formula.\r\n        Returns distance in miles.\r\n        \"\"\"\r\n        # Earth radius in miles\r\n        R = 3958.8\r\n        \r\n        # Convert coordinates from degrees to radians\r\n        lat1_rad = radians(float(lat1))\r\n        lon1_rad = radians(float(lon1))\r\n        lat2_rad = radians(float(lat2))\r\n        lon2_rad = radians(float(lon2))\r\n        \r\n        # Difference in coordinates\r\n        dlat = lat2_rad - lat1_rad\r\n        dlon = lon2_rad - lon1_rad\r\n        \r\n        # Haversine formula\r\n        a = sin(dlat/2)**2 + cos(lat1_rad) * cos(lat2_rad) * sin(dlon/2)**2\r\n        c = 2 * atan2(sqrt(a), sqrt(1-a))\r\n        distance = R * c\r\n        \r\n        return distance\r\n\r\n    def generate_map(self, center_lat, center_lon, radius_miles, events):\r\n        m = folium.Map(location=[center_lat, center_lon], zoom_start=12)\r\n        radius_in_meters = radius_miles * 1609.34\r\n\r\n        folium.Circle(\r\n            location=[center_lat, center_lon],\r\n            radius=radius_in_meters,\r\n            color='#3186cc',\r\n            fill=True,\r\n            fill_color='#3186cc',\r\n            fill_opacity=0.2,\r\n            tooltip=f\"{radius_miles:.1f} miles radius\"\r\n        ).add_to(m)\r\n        marker_cluster = MarkerCluster().add_to(m)\r\n\r\n        for event in events:\r\n            try:\r\n                event_date_str = event.event_date.strftime('%B %d, %Y at %I:%M %p')\r\n            except AttributeError:\r\n                event_date_str = \"Date not available\"\r\n\r\n            popup_html = f\"\"\"\r\n            <div class=\"event-popup\">\r\n                <h3>{event.title}</h3>\r\n                <p><strong>Date:</strong> {event_date_str}</p>\r\n                <p><strong>Category:</strong> {event.category or 'N/A'}</p>\r\n                <p>{event.description or 'No description available.'}</p>\r\n            </div>\r\n            \"\"\"\r\n\r\n            folium.Marker(\r\n                location=[event.latitude, event.longitude],\r\n                popup=folium.Popup(popup_html, max_width=300),\r\n                tooltip=event.title,\r\n                icon=folium.Icon(icon=\"info-sign\", prefix='fa', color=\"blue\"),\r\n            ).add_to(marker_cluster)\r\n\r\n        return m._repr_html_()\r\n\r\nclass SettingPage(SessionLoginRequiredMixin,View):\r\n    login_url = 'login'\r\n    def get(self, request):\r\n        email = request.session.get(\"email\")\r\n        if not email:\r\n            return redirect(\"login\") #redirect if unauthenticated\r\n\r\n        try:\r\n            user = User.objects.get(email=email)\r\n            return render(request, \"SettingPage.html\", {\"user\": user})\r\n        except User.DoesNotExist:\r\n            request.session.flush()\r\n            return redirect(\"login\")\r\n\r\n    def post(self, request):\r\n        email = request.session.get(\"email\")\r\n        if not email:\r\n            return redirect(\"login\")  #redirect if unauthenticated\r\n\r\n        try:\r\n            user = User.objects.get(email=email)\r\n        except User.DoesNotExist:\r\n            request.session.flush()\r\n            return redirect('login')\r\n\r\n        if \"logout\" in request.POST:\r\n            request.session.flush()\r\n            return redirect('login')  # Redirects to the root URL (login page)\r\n\r\n        success_message = None\r\n        error_message = None\r\n\r\n        if \"update_email\" in request.POST:\r\n            new_email = request.POST.get(\"email\") #clicked on\r\n            if new_email: #user entered something\r\n                result = change_account_details(user, new_email=new_email)\r\n                if result:\r\n                    success_message = \"Your email has been updated successfully\"\r\n                else:\r\n                    error_message = \"Failed to update email\"\r\n\r\n        elif \"update_username\" in request.POST:\r\n            new_username = request.POST.get(\"username\")\r\n            if new_username:\r\n                result = change_account_details(user, new_username=new_username)\r\n                if result:\r\n                    success_message = \"Your username has been updated successfully\"\r\n                else:\r\n                    error_message = \"Failed to update your username\"\r\n\r\n        elif \"update_first_name\" in request.POST:\r\n            new_first_name = request.POST.get(\"first_name\")\r\n            if new_first_name:\r\n                result = change_account_details(user, new_first_name=new_first_name)\r\n                if result:\r\n                    success_message = \"Your first name has been updated successfully\"\r\n                else:\r\n                    error_message = \"Failed to update your first name\"\r\n\r\n        elif \"update_last_name\" in request.POST:\r\n            new_last_name = request.POST.get(\"last_name\")\r\n            if new_last_name:\r\n                result = change_account_details(user, new_last_name=new_last_name)\r\n                if result:\r\n                    success_message = \"Your last name has been updated successfully\"\r\n                else:\r\n                    error_message = \"Failed to update your last name\"\r\n        \r\n        elif \"update_phone_number\" in request.POST:\r\n            new_phone_number = request.POST.get(\"phone_number\")\r\n            if new_phone_number:\r\n                result = change_account_details(user, new_phone_number=new_phone_number)\r\n                if result:\r\n                    success_message = \"Your phone number has been updated successfully\"\r\n                else:\r\n                    error_message = \"Failed to update your phone number\"\r\n\r\n\r\n        if success_message:\r\n            return redirect(\"settings\")\r\n\r\n        return render(request, \"SettingPage.html\", {\r\n            \"user\": user,\r\n            \"success\": success_message,\r\n            \"error\": error_message\r\n        })\r\n\r\n\r\nclass SignOutView(View):\r\n    def post(self, request):\r\n        request.session.clear()\r\n        request.session.flush()\r\n        return redirect('login')\r\n\r\n\r\n#Override auth_views.PasswordResetView\r\nclass PasswordResetView(View):\r\n\r\n    def get(self, request):\r\n        return render(request, \"password_reset.html\")\r\n\r\n    def post(self, request):\r\n        #put in method where it sends via sendgrid\r\n        from Methods.sendgrid_reset import send_reset_email\r\n        check = Reset()\r\n        email = request.POST.get('email')\r\n\r\n        user = User.objects.filter(email=email).first()\r\n        #check that the email is valid\r\n        if user:\r\n            if check.authenticate_email(email):\r\n                #then get username\r\n                send_reset_email(request,user)\r\n                #if the email is valid and email is send to user email, go to password_reset_done page\r\n                return redirect(\"password_reset_done\")\r\n            else:\r\n                return render(request, \"password_reset.html\", {\"error\": \"Invalid email\"})\r\n        else:\r\n            return render(request, \"password_reset.html\", {\"error\": \"Invalid email\"})\r\nclass PasswordResetDoneView(View):\r\n    def get(self, request,):\r\n        return render(request, \"password_reset_sent.html\")\r\n\r\nclass PasswordResetConfirmView(View):\r\n\r\n    def get(self, request, uidb64, token):\r\n        token_generator = CustomTokenGenerator()\r\n        try:\r\n            uid = urlsafe_base64_decode(uidb64).decode()\r\n            user = User.objects.get(pk=uid)\r\n        except (User.DoesNotExist, ValueError, TypeError):\r\n            user = None\r\n\r\n        if user and token_generator.check_token(user, token):\r\n            return render(request, \"password_reset_form.html\", {\"valid\": True, \"uidb64\": uidb64, \"token\": token})\r\n        else:\r\n            return render(request, \"password_reset_form.html\", {\"valid\": False, \"error\": \"Invalid or expired token\"})\r\n\r\n    def post(self, request, uidb64, token):\r\n\r\n        try:\r\n            uid = urlsafe_base64_decode(uidb64).decode()\r\n            user = User.objects.get(pk=uid)\r\n        except (User.DoesNotExist, ValueError, TypeError):\r\n            user = None\r\n\r\n        errors = {}\r\n        check = Reset()\r\n\r\n        password1 = request.POST.get('password1')\r\n        password2 = request.POST.get('password2')\r\n\r\n        if user:\r\n            # Check if the password meets the length requirements\r\n            if check.pass_maximum(password1):\r\n                # Check if the two passwords match\r\n                if check.pass_exact(password1, password2):\r\n                    check.set_password(user.email, password1)\r\n                    return redirect(\"password_reset_complete\")\r\n                else:\r\n                    errors[\"match\"] = \"Passwords don't match\"\r\n            else:\r\n                errors[\"char\"] = \"Password must be more than 0 characters but less than 51 characters\"\r\n        else:\r\n            # Return error if the token is invalid or expired\r\n            errors[\"token\"] = [\"Invalid or expired token\"]\r\n\r\n            # Render error messages\r\n        return render(request, \"password_reset_form.html\", {\"errors\": errors, \"user_data\": request.POST})\r\n\r\nclass WeatherView(View):\r\n    def get(self, request):\r\n        # Render the weather form template for GET requests\r\n        return render(request, \"weather.html\")\r\n\r\n    def post(self, request):\r\n        api_key = '438802557a5074e655e46b4140076665'  # Consider moving this to settings.py for better security\r\n        location_type = request.POST.get('locationType')\r\n        location_input = request.POST.get('locationInput').strip()\r\n\r\n        if not location_input:\r\n            return render(request, \"weather.html\", {'error': 'Please enter a location.'})\r\n\r\n        api_url = f'httpshttps://api.openweathermap.org/data/2.5/forecast?appid={api_key}&units=metric'\r\n\r\n        try:\r\n            if location_type == 'city':\r\n                api_url += f'&q={location_input}'\r\n            elif location_type == 'zip':\r\n                if not location_input.isdigit() or len(location_input) != 5:\r\n                    return render(request, \"weather.html\", {'error': 'Invalid zip code format.'})\r\n                api_url += f'&zip={location_input}'\r\n            elif location_type == 'coords':\r\n                lat, lon = map(str.strip, location_input.split(','))\r\n                if not (lat.replace('.', '').isdigit() and lon.replace('.', '').isdigit()):\r\n                    return render(request, \"weather.html\", {'error': 'Invalid coordinates format.'})\r\n                api_url += f'&lat={lat}&lon={lon}'\r\n            else:\r\n                return render(request, \"weather.html\", {'error': 'Invalid location type.'})\r\n\r\n            response = requests.get(api_url)\r\n\r\n            # Check for a 404 response and return a friendly error message\r\n            if response.status_code == 404:\r\n                return render(request, \"weather.html\", {'error': 'Location not found. Please check your spelling.'})\r\n\r\n            response.raise_for_status()  # Raise an exception for other HTTP errors\r\n            weather_data = response.json()\r\n\r\n            # Convert temperatures from Celsius to Fahrenheit\r\n            for item in weather_data['list']:\r\n                item['main']['temp'] = (item['main']['temp'] * 9/5) + 32\r\n\r\n            return render(request, \"weather.html\", {'weather_data': weather_data})\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            return render(request, \"weather.html\", {'error': f'Failed to fetch weather data: {str(e)}'})\r\n\r\nclass DeleteView(View):\r\n    # DELETE page\r\n    # Send to page that confirms that they understand that they will not be able to retrieve their account\r\n    # If they click yes, they get brought to a page that they enter their email and enter their password two times\r\n    # if they successfully enter the right email and passwords, the account is deleted and if it is successfully\r\n    # deleted, they are redirected to a page that they successfully deleted account and go to login page\r\n\r\n    def get(self, request):\r\n        return render(request, \"delete.html\")\r\n    def post(self,request):\r\n\r\n        #Get the input information\r\n        email=request.POST.get('email')\r\n        password1 = request.POST.get('password1')\r\n        password2 = request.POST.get('password2')\r\n        auth = DeleteAcct()\r\n        # Check if fields are blank\r\n        if auth.isNotBlank(email, password1, password2):\r\n            session_user=request.session.get('email')\r\n            if session_user != email:\r\n                return render(request, \"delete.html\", {\"error\": \"Incorrect Email\"})\r\n\r\n            #Check if fields are blank\r\n            #Check if passwords match\r\n            if not auth.pass_exact(password1,password2):\r\n                return render(request, \"delete.html\", {\"error\": \"Passwords don't match\"})\r\n\r\n\r\n            if not auth.del_acct(email,password1,password2):\r\n                return render(request, \"delete.html\", {\"error\": \"Incorrect Email or Password\"})\r\n            else:\r\n                request.session.clear()\r\n                return redirect(\"delete_complete\")\r\n\r\n        #If none, return error at bottom of page\r\n        else:\r\n            return render(request, \"delete.html\", {\"error\": \"Enter an email and password\"})\r\n\r\n\r\nclass DeleteCompleteView(View):\r\n    def get(self,request):\r\n        return render(request, \"delete_complete.html\")\r\n\r\n@csrf_exempt\r\n@require_POST\r\ndef fetch_and_save_events_api(request):\r\n    try:\r\n        data = json.loads(request.body)\r\n        lat = float(data['latitude'])\r\n        lon = float(data['longitude'])\r\n        radius = float(data['radius'])\r\n        location_name = data.get('location_name', 'Unknown Location')\r\n\r\n        logger.info(f\"API endpoint called: Fetching events for lat={lat}, lon={lon}, radius={radius}\")\r\n        api_start_time = time.time()\r\n        features = fetch_events_from_api(lat, lon, radius, EVENT_API_KEY)\r\n        api_end_time = time.time()\r\n        logger.info(f\"API fetch took {api_end_time - api_start_time:.2f} seconds.\")\r\n\r\n        if features:\r\n            logger.info(f\"API returned {len(features)} events.\")\r\n\r\n            logger.info(\"Starting bulk processing and saving/updating events...\")\r\n            start_time = time.time()\r\n            num_processed = 0\r\n            events_to_create = []\r\n            events_to_update = []\r\n            created_count = 0\r\n            updated_count = 0\r\n            update_fields = ['title', 'latitude', 'longitude', 'description', 'location_name', 'event_date', 'category', 'image_url'] # Fields to update\r\n\r\n            try:\r\n                admin_user = User.objects.get(email='system@eventradar.local')\r\n            except User.DoesNotExist:\r\n                logger.error(\"System user not found during API fetch.\")\r\n                return JsonResponse({'status': 'error', 'message': 'Internal configuration error: System user missing.'}, status=500)\r\n\r\n            api_place_ids = [f['properties'].get('place_id') for f in features if f.get('properties', {}).get('place_id')]\r\n            if not api_place_ids:\r\n                 logger.info(\"No valid place_ids found in API response.\")\r\n            else:\r\n                existing_events = Event.objects.filter(place_id__in=api_place_ids).in_bulk(field_name='place_id')\r\n                logger.info(f\"Found {len(existing_events)} existing events in DB for comparison.\")\r\n\r\n                for feature in features:\r\n                    props = feature.get('properties', {})\r\n                    geometry = feature.get('geometry', {})\r\n                    place_id = props.get('place_id')\r\n\r\n                    if not place_id or not geometry or 'coordinates' not in geometry:\r\n                        continue\r\n\r\n                    latitude = geometry['coordinates'][1]\r\n                    longitude = geometry['coordinates'][0]\r\n                    \r\n                    description_parts = []\r\n                    for key in ['address_line1', 'address_line2', 'address_line3', 'phone', 'website', 'datasource_name']:\r\n                        if props.get(key):\r\n                            description_parts.append(props.get(key))\r\n                    \r\n                    street = props.get('street')\r\n                    if street and street not in description_parts:\r\n                        description_parts.append(f\"Street: {street}\")\r\n                    \r\n                    description = \"\\n\".join(description_parts)\r\n                    \r\n                    title = None\r\n                    \r\n                    if props.get('name'):\r\n                        title = props.get('name')\r\n                    \r\n                    elif props.get('street'):\r\n                        house_number = props.get('housenumber', '')\r\n                        street = props.get('street', '')\r\n                        if house_number and street:\r\n                            title = f\"{house_number} {street}\"\r\n                        else:\r\n                            title = street\r\n                    \r\n                    elif props.get('city') or props.get('locality'):\r\n                        location_prefix = props.get('city') or props.get('locality')\r\n                        street = props.get('street', '')\r\n                        if street:\r\n                            title = f\"{street}, {location_prefix}\"\r\n                        else:\r\n                            title = location_prefix\r\n                    \r\n                    elif props.get('formatted'):\r\n                        address_parts = props.get('formatted', '').split(',')\r\n                        if address_parts:\r\n                            title = address_parts[0].strip()\r\n                    \r\n                    if not title:\r\n                        api_categories = props.get('categories', [])\r\n                        if api_categories:\r\n                            category_parts = api_categories[0].split('.')\r\n                            title = category_parts[-1].replace('_', ' ').title()\r\n                        else:\r\n                            title = \"Location Point\"\r\n                    \r\n                    api_categories = props.get('categories', [])\r\n                    category_label = None\r\n                    \r\n                    if api_categories:\r\n                        for cat in api_categories:\r\n                            if cat in category_mapping:\r\n                                category_label = category_mapping[cat]\r\n                                break\r\n                    \r\n                    if not category_label and api_categories:\r\n                        for cat in api_categories:\r\n                            cat_prefix = cat.split('.')[0]\r\n                            for map_key, map_value in category_mapping.items():\r\n                                if map_key.startswith(cat_prefix):\r\n                                    category_label = map_value\r\n                                    break\r\n                            if category_label:\r\n                                break\r\n                    \r\n                    if not category_label and api_categories:\r\n                        main_parts = api_categories[0].split('.')\r\n                        \r\n                        if len(main_parts) > 1:\r\n                            specific_type = main_parts[-1].replace('_', ' ').title()\r\n                            category_label = specific_type\r\n                        else:\r\n                            category_label = main_parts[0].replace('_', ' ').title()\r\n                    \r\n                    if not category_label:\r\n                        category_label = 'Point of Interest'\r\n                    \r\n                    formatted_location = props.get('formatted', location_name)\r\n                    image_url = props.get('datasource', {}).get('raw', {}).get('image')\r\n                    \r\n                    logger.info(f\"Processing place: {title} | Categories: {api_categories} | Mapped to: {category_label}\")\r\n                    \r\n                    existing_event = existing_events.get(place_id)\r\n\r\n                    if existing_event:\r\n                        update_needed = False\r\n                        for field in update_fields:\r\n                            new_value = locals().get(field)\r\n                            if field == 'event_date': new_value = timezone.now()\r\n                            if getattr(existing_event, field) != new_value:\r\n                                setattr(existing_event, field, new_value)\r\n                                update_needed = True\r\n                        if update_needed:\r\n                            events_to_update.append(existing_event)\r\n                    else:\r\n                        events_to_create.append(\r\n                            Event(\r\n                                place_id=place_id,\r\n                                title=title,\r\n                                latitude=latitude,\r\n                                longitude=longitude,\r\n                                description=description,\r\n                                location_name=formatted_location,\r\n                                event_date=timezone.now(),\r\n                                created_by=admin_user,\r\n                                category=category_label,\r\n                                image_url=image_url,\r\n                            )\r\n                        )\r\n                    num_processed += 1\r\n\r\n                created_count = 0\r\n                if events_to_create:\r\n                    try:\r\n                        created_objs = Event.objects.bulk_create(events_to_create)\r\n                        created_count = len(created_objs)\r\n                        logger.info(f\"Bulk created {created_count} new events.\")\r\n                    except Exception as e:\r\n                        logger.error(f\"Error during bulk_create: {e}\")\r\n\r\n                updated_count = 0\r\n                if events_to_update:\r\n                    try:\r\n                        updated_count = Event.objects.bulk_update(events_to_update, update_fields)\r\n                        logger.info(f\"Bulk updated {updated_count} existing events.\")\r\n                    except Exception as e:\r\n                        logger.error(f\"Error during bulk_update: {e}\")\r\n\r\n\r\n            end_time = time.time()\r\n            total_time = end_time - start_time\r\n            logger.info(f\"Finished bulk processing {num_processed} events in {total_time:.2f} seconds.\")\r\n\r\n            logger.info(f\"Updating SearchedArea: lat={lat}, lon={lon}, radius={radius}, has_events=True\")\r\n            SearchedArea.objects.update_or_create(\r\n                latitude=lat, longitude=lon, radius=radius,\r\n                defaults={'has_events': True, 'last_checked': timezone.now()}\r\n            )\r\n\r\n            logger.info(f\"API endpoint: Saved {created_count} new events via bulk.\")\r\n            return JsonResponse({\r\n                'status': 'success',\r\n                'message': f'{created_count} new events found and saved.',\r\n                'processed_count': num_processed\r\n            })\r\n        else:\r\n            created_count = 0\r\n            num_processed = 0\r\n            logger.info(f\"Updating SearchedArea: lat={lat}, lon={lon}, radius={radius}, has_events=False (API fetch failed)\")\r\n            SearchedArea.objects.update_or_create(\r\n                latitude=lat, longitude=lon, radius=radius,\r\n                defaults={'has_events': False, 'last_checked': timezone.now()}\r\n            )\r\n            logger.info(\"API endpoint: No events found or API error occurred.\")\r\n            return JsonResponse({\r\n                'status': 'success',\r\n                'message': 'No new events found or API error occurred.',\r\n                'processed_count': 0\r\n            })\r\n\r\n    except json.JSONDecodeError:\r\n        logger.error(\"API endpoint: Invalid JSON received.\")\r\n        return JsonResponse({'status': 'error', 'message': 'Invalid request format.'}, status=400)\r\n    except (KeyError, ValueError, TypeError) as e:\r\n        logger.error(f\"API endpoint: Invalid data received - {e}\")\r\n        return JsonResponse({'status': 'error', 'message': f'Invalid data: {e}'}, status=400)\r\n    except Exception as e:\r\n        logger.exception(\"API endpoint: An unexpected error occurred.\")\r\n        return JsonResponse({'status': 'error', 'message': 'An internal server error occurred.'}, status=500)\r\n\r\n###application\r\n#make sure this is only viewable through users/admins (not event managers) only\r\nclass ApplicationClass(UserRequiredMixin,View):\r\n    def get(self, request):\r\n        return render(request, \"application.html\")\r\n    def post(self, request):\r\n        auth=VerifyAccount()\r\n        applic=ApplicationMethods()\r\n        session_user = request.session.get('email')\r\n        #get the user from session\r\n        email = request.session.get(\"email\")\r\n        user = User.objects.get(email=email)  # Find user by email\r\n        message = request.POST.get('app_message', '')\r\n        #check that the form is under 3000 characters\r\n        if message and len(message)<3000:\r\n            applic.create_app(user=user,message=message)\r\n\r\n            return redirect(\"app_confirmation\")\r\n\r\n        else:\r\n            return render(request, \"application.html\", {\"error\": \"Invalid message\"})\r\n\r\n\r\n        #create form object\r\nclass App_Confirm(View):\r\n    def get(self, request):\r\n        return render(request, \"App_Confirm.html\")\r\n\r\nclass Approval(AdminRequiredMixin,View):\r\n    def get(self, request):\r\n        pending_apps = Application.objects.filter(status=ApplicationStatus.PENDING)\r\n\r\n        return render(request, \"admin_app_approval.html\",{'applications': pending_apps})\r\n\r\n    def post(self, request):\r\n        #load all applications that have pending status\r\n        application_id = request.POST.get('application_id')  #Get the app id\r\n        action = request.POST.get('action') #getting the action\r\n\r\n        if application_id and action:\r\n            application = get_object_or_404(Application, id=application_id)\r\n\r\n            #If accepted button is pressed\r\n            #Put status as accepted\r\n            if action == 'accept':\r\n                application.status = \"Accepted\"\r\n                application.save()\r\n\r\n                #change user's role to event manager\r\n                user = application.user\r\n                user.role = 'Event_Manager'\r\n                user.save()\r\n\r\n            #if denied\r\n            #just change app status\r\n            elif action == 'deny':\r\n                application.status = \"Denied\"\r\n                application.save()\r\n\r\n                # After processing, redirect back to the application approval page\r\n            return redirect('app_approve')\r\n\r\n        # If something went wrong, redirect back to the same page\r\n        return redirect('app_approve')\r\n\r\ndef get_event_details(request, event_id):\r\n    try:\r\n        event = Event.objects.get(id=event_id)\r\n\r\n        phone = None\r\n        website = None\r\n        if event.description:\r\n            phone_match = re.search(r'\\b(?:\\+\\d{1,2}\\s)?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\\b', event.description)\r\n            phone = phone_match.group(0) if phone_match else None\r\n            website_match = re.search(r'https?://[^\\s]+', event.description)\r\n            website = website_match.group(0) if website_match else None\r\n\r\n\r\n        return JsonResponse({\r\n            'id': str(event.id),\r\n            'title': event.title,\r\n            'description': event.description,\r\n            'location_name': event.location_name,\r\n            'latitude': event.latitude,\r\n            'longitude': event.longitude,\r\n            'category': event.category,\r\n            'image_url': event.image_url,\r\n            'event_date': event.event_date.strftime('%B %d, %Y at %I:%M %p') if event.event_date else None,\r\n            'phone': phone,\r\n            'website': website\r\n        })\r\n    except Event.DoesNotExist:\r\n        return JsonResponse({'error': 'Event not found'}, status=404)\r\n\r\ndef event_details_page(request, event_id):\r\n    event = get_object_or_404(Event, id=event_id)\r\n    place_details = fetch_place_details(event.place_id)\r\n\r\n    context = {\r\n        'event': event,\r\n        'place_details': place_details\r\n    }\r\n    return render(request, 'event_details.html', context)\r\n\r\ndef fetch_place_details(place_id):\r\n    api_url = f\"https://api.geoapify.com/v2/place-details?id={place_id}&apiKey={settings.EVENT_API_KEY}\"\r\n    try:\r\n        response = requests.get(api_url)\r\n        response.raise_for_status()\r\n        return response.json()\r\n    except requests.exceptions.RequestException as e:\r\n        logger.error(f\"Failed to fetch place details: {e}\")\r\n    return None\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/polls/views.py b/polls/views.py
--- a/polls/views.py	(revision 129356ca42e355b30ffd5c56aa82458caa6f4a5d)
+++ b/polls/views.py	(date 1744308907278)
@@ -227,6 +227,9 @@
         return render(request, "homepage.html", context)
 
     def post(self, request):
+        #Getting selection of events
+        #processes time and date of user made event
+
         location_name = request.POST.get('location', 'Milwaukee')
         radius = request.POST.get('radius', 5)
 
